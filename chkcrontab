#! /usr/bin/perl

use warnings; use strict;

my %none = ();
my %monthnames = validnames(qw/january february march april may june july august september october november december/);
my %daynames = validnames(qw/sunday monday tuesday wednesday thursday friday saturday/);

my @crontab;
my $exitstat = 0;
if (@ARGV) {
    foreach (@ARGV) {
        if (-r $_) {
	    if (open(my $crontab, '<', $_)) {
    		$exitstat = 1 if !chkcrontab($crontab, -3);
            } else {
        	warn "$0: Failed to read $_: $!\n";
            }
    } else {
        warn "$0: Cannot read $_\n";
	$exitstat = 1;
    }
} elsif (open(my $crontab, 'crontab -l |')) {
    $exitstat = 1 if !chkcrontab($crontab, 0); 
}

exit $exitstat;

sub chkcrontab {
    my ($fh, $lineno) = @_;

    my $retval = 1;
    while (<$fh>) {
	$lineno++;
	if (/^\s*#/) {
	    next;
	}
	my @field = split(/\s+/, $_);
	shift @field if length($field[0]) == 0;
	if (!check($field[0], \%none)) {
	    print STDERR "$lineno: bad minutes specification: $field[0]\n";
	    $retval = 0;
	}
	if (!check($field[1], \%none)) {
	    print STDERR "$lineno: bad hours specification: $field[1]\n";
	    $retval = 0;
	}
	if (!check($field[2], \%none)) {
	    print STDERR "$lineno: bad day of month specification: $field[2]\n";
	    $retval = 0;
	}
	if (!check($field[3], \%monthnames)) {
	    print STDERR "$lineno: bad month specification: $field[3]\n";
	    $retval = 0;
	}
	if (!check($field[4], \%daynames)) {
	    print STDERR "$lineno: bad day of week specification: $field[4]\n";
	    $retval = 0;
	}
	if (! -e $field[5]) {
	    print STDERR "$lineno: \"$field[5]\" does not exist\n";
	    $retval = 0;
	} elsif (! -x $field[5]) {
	    print STDERR "$lineno: \"$field[5]\" is not executable\n";
	    $retval = 0;
	}
    }

    return $retval;
}

sub check {
    my ($spec, $nameref) = @_;

    # split comma-seperated specifications.
    foreach (split(/,/, $spec)) {
	my ($base, $step, $tail) = split(/\//);

	# Only one step specification is allowed
	return 0 if defined $tail;

	# The step must be purely numeric
	if (defined $step) {
	    return 0 if $step !~ m|^\d+|;
	}

	# each part must be either a number without a step or a range ('* is a valid range) optionally followed by a step
	if ($base =~ m|^\d+$|) {
	    return 0 if defined $step;
	} elsif (!exists $nameref->{lc $base}) {
	    if ($base =~ m|^(\d+)-(\d+)|) {
	        return 0 if $1 > $2;
	    } elsif ($base ne '*') {
	        return 0;
	    }
	}
    }

    return 1;
}

sub validnames {
    my %list;

    foreach (@_) {
        $list{$_} = 1;
	$list{substr($_, 0, 3)} = 1;
    }

    return %list;
}
